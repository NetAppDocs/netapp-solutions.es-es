---
sidebar: sidebar 
permalink: containers/rh-os-n_use_case_openshift_virtualization_trident_install.html 
keywords: OpenShift, OCP, Trident, Trident protect, NetApp ONTAP, Red Hat OpenShift, OpenShift Virtualization, Red Hat OpenShift Virtualization 
summary: OpenShift Virtualization de Red Hat con ONTAP de NetApp 
---
= Instalación de Trident y creación de objetos Trident.
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ../media/


[role="lead"]
En esta sección se detalla cómo instalar Trident para preparar los nodos de trabajo para el acceso a bloques. Proporciona instrucciones paso a paso para crear los objetos de clase de almacenamiento y back-end de Trident. El objeto de back-end Trident incluye todos los detalles necesarios para conectarse al sistema de almacenamiento ONTAP de back-end y aprovisionar volúmenes de forma dinámica en ONTAP para el protocolo especificado. El objeto de clase de almacenamiento permite que las aplicaciones de contenedores y las máquinas virtuales soliciten el almacenamiento usando solo el tipo y la capacidad, sin necesitar conectividad ni otros detalles de back-end.


NOTE: Si necesita crear máquinas virtuales en OpenShift Virtualization, Trident debe estar instalado y los objetos de back-end y los objetos de clase de almacenamiento deben crearse en el cluster OpenShift antes de instalar OpenShift Virtualization en el cluster. La clase de almacenamiento predeterminada y la clase de snapshot de volumen predeterminada deben establecerse en el almacenamiento Trident y la clase de snapshot en el clúster. Solo cuando se configura esto, la virtualización de OpenShift puede descargar imágenes maestras y ponerlas a disposición de la creación de VM mediante plantillas.

**Instalación de Trident**

.Instalación de Trident con el operador certificado de Red Hat
[%collapsible%open]
====
En esta sección, se proporcionan detalles sobre la instalación de Trident con el operador Trident certificado de Red Hat. link:https://docs.netapp.com/us-en/trident/trident-get-started/kubernetes-deploy.html["Consulte la documentación de Trident"] Para otras formas de instalar Trident. Con el lanzamiento de Trident 25,02, los usuarios de Trident en Red Hat OpenShift en las instalaciones y en la nube y servicios gestionados como Red Hat OpenShift Service en AWS ahora pueden instalar Trident mediante el Operador certificado de Trident desde el Centro de operadores. Esto es importante para la comunidad de usuarios de OpenShift, ya que antes Trident solo estaba disponible como operador de la comunidad.

La ventaja del operador Red Hat Certified Trident es que la base del operador y sus contenedores es totalmente compatible con NetApp cuando se utiliza con OpenShift (ya sea en las instalaciones, en la nube o como servicio gestionado). Además, NetApp Trident no tiene ningún coste para el cliente, por lo que solo tiene que instalarlo con el operador certificado que se ha verificado para que funcione sin problemas con Red Hat OpenShift y que se ha empaquetado para facilitar la gestión del ciclo de vida.

Para instalar Trident con el operador, haga clic en Hub del operador y seleccione NetApp Trident certificado. En la página Instalar, la última versión se selecciona de forma predeterminada. Haga clic en Instalar. image:rh-os-n_use_case_openshift_virtualization_trident_install_img1.png["buje del operador"]

image:rh-os-n_use_case_openshift_virtualization_trident_install_img2.png["instale"]

Una vez instalado el operador, haga clic en el operador de vista y, a continuación, cree una instancia del orquestador de Trident. Si desea preparar los nodos de trabajo para el acceso al almacenamiento iSCSI, vaya a la vista yaml y modifique el parámetro nodePrep agregando iscsi.

image:rh-os-n_use_case_openshift_virtualization_trident_install_img3.png["añada iscsi para la preparación del nodo"]

Ahora debería tener todos los pods de Trident ejecutándose en su clúster. image:rh-os-n_use_case_openshift_virtualization_trident_install_img4.png["Trident instalado"]

Para comprobar que las herramientas iSCSI se han activado en los nodos de trabajo del cluster OpenShift, inicie sesión en los nodos de trabajo y compruebe que aparece iscsid, multipathd active y las entradas en el archivo multipath.conf como se muestra.

image:rh-os-n_use_case_openshift_virtualization_trident_install_img5.png["iscsid en ejecución"]

image:rh-os-n_use_case_openshift_virtualization_trident_install_img6.png["multipathd en ejecución"]

image:rh-os-n_use_case_openshift_virtualization_trident_install_img7.png["archivo multipathconf en ejecución"]

====
**Configuración de Trident para clúster OpenShift en las instalaciones**

.Back-end de Trident y clase de almacenamiento para NAS
[%collapsible%open]
====
[source, yaml]
----
cat tbc-nas.yaml
apiVersion: v1
kind: Secret
metadata:
  name: tbc-nas-secret
type: Opaque
stringData:
  username: <cluster admin username>
  password: <cluster admin password>
---
apiVersion: trident.netapp.io/v1
kind: TridentBackendConfig
metadata:
  name: tbc-nas
spec:
  version: 1
  storageDriverName: ontap-nas
  managementLIF: <cluster management lif>
  backendName: tbc-nas
  svm: zoneb
  storagePrefix: testzoneb
  defaults:
    nameTemplate: "{{ .config.StoragePrefix }}_{{ .volume.Namespace }}_{{ .volume.RequestName }}"
  credentials:
    name: tbc-nas-secret
----
[source, yaml]
----
cat sc-nas.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: sc-nas
provisioner: csi.trident.netapp.io
parameters:
  backendType: "ontap-nas"
  media: "ssd"
  provisioningType: "thin"
  snapshots: "true"
allowVolumeExpansion: true
----
====
.Back-end de Trident y clase de almacenamiento para iSCSI
[%collapsible%open]
====
[source, yaml]
----
# cat tbc-iscsi.yaml
apiVersion: v1
kind: Secret
metadata:
  name: backend-tbc-ontap-iscsi-secret
type: Opaque
stringData:
  username: <cluster admin username>
  password: <cluster admin password>
---
apiVersion: trident.netapp.io/v1
kind: TridentBackendConfig
metadata:
  name: ontap-iscsi
spec:
  version: 1
  storageDriverName: ontap-san
  managementLIF: <management LIF>
  backendName: ontap-iscsi
  svm: <SVM name>
  credentials:
    name: backend-tbc-ontap-iscsi-secret
----
[source, yaml]
----
# cat sc-iscsi.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: sc-iscsi
provisioner: csi.trident.netapp.io
parameters:
  backendType: "ontap-san"
  media: "ssd"
  provisioningType: "thin"
  fsType: ext4
  snapshots: "true"
allowVolumeExpansion: true
----
====
.Back-end de Trident y clase de almacenamiento para NVMe/TCP
[%collapsible%open]
====
[source, yaml]
----
# cat tbc-nvme.yaml
apiVersion: v1
kind: Secret
metadata:
  name: backend-tbc-ontap-nvme-secret
type: Opaque
stringData:
  username: <cluster admin password>
  password: <cluster admin password>
---
apiVersion: trident.netapp.io/v1
kind: TridentBackendConfig
metadata:
  name: backend-tbc-ontap-nvme
spec:
  version: 1
  storageDriverName: ontap-san
  managementLIF: <cluster management LIF>
  backendName: backend-tbc-ontap-nvme
  svm: <SVM name>
  credentials:
    name: backend-tbc-ontap-nvme-secret
----
[source, yaml]
----
# cat sc-nvme.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: sc-nvme
provisioner: csi.trident.netapp.io
parameters:
  backendType: "ontap-san"
  media: "ssd"
  provisioningType: "thin"
  fsType: ext4
  snapshots: "true"
allowVolumeExpansion: true
----
====
.Back-end de Trident y clase de almacenamiento para FC
[%collapsible%open]
====
[source, yaml]
----
# cat tbc-fc.yaml
apiVersion: v1
kind: Secret
metadata:
  name: tbc-fc-secret
type: Opaque
stringData:
  username: <cluster admin password>
  password: <cluster admin password>
---
apiVersion: trident.netapp.io/v1
kind: TridentBackendConfig
metadata:
  name: tbc-fc
spec:
  version: 1
  storageDriverName: ontap-san
  managementLIF: <cluster mgmt lif>
  backendName: tbc-fc
  svm: openshift-fc
  sanType: fcp
  storagePrefix: demofc
  defaults:
    nameTemplate: "{{ .config.StoragePrefix }}_{{ .volume.Namespace }}_{{ .volume.RequestName }}"
  credentials:
    name: tbc-fc-secret
----
[source, yaml]
----
# cat sc-fc.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: sc-fc
provisioner: csi.trident.netapp.io
parameters:
  backendType: "ontap-san"
  media: "ssd"
  provisioningType: "thin"
  fsType: ext4
  snapshots: "true"
allowVolumeExpansion: true
----
====
**Configuración Trident para clúster ROSA usando almacenamiento FSxN**

.Backend de Trident y clase de almacenamiento para FSxN NAS
[%collapsible%open]
====
[source, yaml]
----
#cat tbc-fsx-nas.yaml
apiVersion: v1
kind: Secret
metadata:
  name: backend-fsx-ontap-nas-secret
  namespace: trident
type: Opaque
stringData:
  username: <cluster admin lif>
  password: <cluster admin passwd>
---
apiVersion: trident.netapp.io/v1
kind: TridentBackendConfig
metadata:
  name: backend-fsx-ontap-nas
  namespace: trident
spec:
  version: 1
  backendName: fsx-ontap
  storageDriverName: ontap-nas
  managementLIF: <Management DNS name>
  dataLIF: <NFS DNS name>
  svm: <SVM NAME>
  credentials:
    name: backend-fsx-ontap-nas-secret
----
[source, yaml]
----
# cat sc-fsx-nas.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: trident-csi
provisioner: csi.trident.netapp.io
parameters:
  backendType: "ontap-nas"
  fsType: "ext4"
allowVolumeExpansion: True
reclaimPolicy: Retain
----
====
.Backend de Trident y clase de almacenamiento para FSxN iSCSI
[%collapsible%open]
====
[source, yaml]
----
# cat tbc-fsx-iscsi.yaml
apiVersion: v1
kind: Secret
metadata:
  name: backend-tbc-fsx-iscsi-secret
type: Opaque
stringData:
  username: <cluster admin username>
  password: <cluster admin password>
---
apiVersion: trident.netapp.io/v1
kind: TridentBackendConfig
metadata:
  name: fsx-iscsi
spec:
  version: 1
  storageDriverName: ontap-san
  managementLIF: <management LIF>
  backendName: fsx-iscsi
  svm: <SVM name>
  credentials:
    name: backend-tbc-ontap-iscsi-secret
----
[source, yaml]
----
# cat sc-fsx-iscsi.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: sc-fsx-iscsi
provisioner: csi.trident.netapp.io
parameters:
  backendType: "ontap-san"
  media: "ssd"
  provisioningType: "thin"
  fsType: ext4
  snapshots: "true"
allowVolumeExpansion: true
----
====
**Clase de instantánea de volumen Trident**

.Clase de snapshot de volumen Trident
[%collapsible%open]
====
[source, yaml]
----
# cat snapshot-class.yaml
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshotClass
metadata:
  name: trident-snapshotclass
driver: csi.trident.netapp.io
deletionPolicy: Retain
----
====
Una vez que haya instalado los archivos yaml necesarios para la configuración de backend, la configuración de clase de almacenamiento y las configuraciones de instantánea, puede crear el backend de Trident , la clase de almacenamiento y los objetos de clase de instantánea mediante el siguiente comando

[source, yaml]
----
oc create -f <backend-filename.yaml> -n trident
oc create -f < storageclass-filename.yaml>
oc create -f <snapshotclass-filename.yaml>
----
**Configuración de valores predeterminados con Almacenamiento Trident y Clase Instantánea**

.Establecimiento de valores predeterminados con Almacenamiento de Trident y Clase de instantánea
[%collapsible%open]
====
Ahora puede establecer la clase de almacenamiento Trident necesaria y la clase de snapshot para volúmenes como la predeterminada en el clúster de OpenShift. Como se ha mencionado anteriormente, es necesario configurar la clase de almacenamiento y la clase de instantánea de volumen para permitir que OpenShift Virtualization ponga el origen de imagen principal disponible para crear máquinas virtuales a partir de plantillas predeterminadas.

Puede definir la clase de almacenamiento y la clase de instantánea como predeterminada editando la anotación desde la consola o aplicando parches desde la línea de comandos con lo siguiente:

[source, yaml]
----
storageclass.kubernetes.io/is-default-class:true
or
kubectl patch storageclass standard -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'

storageclass.kubevirt.io/is-default-virt-class: true
or
kubectl patch storageclass standard -p '{"metadata": {"annotations":{"storageclass.kubevirt.io/is-default-virt-class": "true"}}}'
----
====